##' Inverse (dose-finding) estimate of a target x value (e.g., a percentile)
#'
#'
#' Inverse ("dose-finding") point estimation of a dose (x) for a specified target y value (e.g., a response rate), using the centered-isotonic-regression (\code{invCIR}) or a generic forward-estimation algorithm (\code{doseFind}).
#'
#'
#' The function works by calling \code{estfun} for forward estimation of the x-y relationship, then using \code{\link{approx}} with the x and y roles reversed for inverse estimation. The \code{extrapolate} option sets the \code{rule} argumet for this second call: 
#' \itemize{
#' \item {}{\code{extrapolate=TRUE} translates to \code{rule=2}, which actually means that the x value on the edge of the estimated y range will be assigned.}
#' \item{}{\code{extrapolate=FALSE} (default) translates to \code{rule=1}, which means an \code{NA} will be returned for any target y value lying outside the estimated y range.}
#' }
#' Note also that the function is set up to work with a vector of targets.
 
##' @author Assaf P. Oron \code{<assaf.oron.at.seattlechildrens.org>}

#' @param y  can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a \code{\link{DRtrace}} object or a \code{\link{doseResponse}} object. 
#' @param x dose levels (if not included in y). 
#' @param wt weights (if not included in y).
#' @param target A vector of target response rate(s), for which the percentile dose estimate is needed.
#' @param full logical, is a more complete output desired (relevant only for doseFind)? if \code{FALSE} (default), only a point estimate of the dose (x) for the provided target rate is returned
#' @param extrapolate logical: should extrapolation beyond the range of estimated y values be allowed? Default \code{FALSE}.
#' @param dec (relevant only for doseFind) logical, is the true function is assumed to be monotone decreasing? Default \code{FALSE}.
#' @param estfun the name of the dose-response estimation function (relevant only for doseFind). For \code{invCIR} this is hard-coded as \code{\link{cirPAVA}}, which is also the default for \code{doseFind}.
#' @param ...	Other arguments passed on, from \code{invCIR} to \code{doseFind} and from there to the constructor functions that pre-process the input.

#' @return under default, returns point estimate(s) of the dose (x) for the provided target rate(s). With \code{full=TRUE}, returns a list with
#' \itemize{
#' \item {xout } {  The said point estimate of x}
#' \item {input  }  {  a \code{doseResponse} object summarizing the input data}
#' \item {cir  }  {  a \code{doseResponse} object which is the \code{alg} output of the forward-estimation function}
#' }

#' @seealso \code{\link{pava}},\code{\link{cirPAVA}}

#' @export

doseFind<-function(y,x=NULL,wt=rep(1,length(y)),estfun=cirPAVA,target,full=FALSE,dec=FALSE,extrapolate=FALSE,...) {


### converting to doseResponse object 
### Basically it's a numeric data frame with x,y,weight, and x increasing

dr=doseResponse(y=y,x=x,wt=wt,...)
if (any(is.na(dr))) stop ("Missing values are not allowed.\n")  

# We start via forward estimation

pavout<-estfun(y=dr,full=TRUE,dec=dec)

newx<-pavout$alg$x
newy<-pavout$alg$y
newn=pavout$alg.wt

### The estimate is generated by using 'approx' with x and y interchanged

tout=approx(x=newy,y=newx,xout=target,ties="ordered",rule=ifelse(extrapolate,2,1))$y

#### output

if (!full)  return(tout) 

return (list(targest=tout,input=dr,fwd=pavout$alg))
}

#' Point and Interval Inverse Estimation using CIR and IR
#'
#'
#' Convenience wrapper for point and interval estimation of the "dose" that would generate a \code{target} "response" value, using CIR and IR.

#' @param y  can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a \code{\link{DRtrace}} object or a \code{\link{doseResponse}} object. 
#' @param x dose levels (if not included in y). 
#' @param wt weights (if not included in y).
#' @param target A vector of target response rate(s), for which the percentile dose estimate is needed.
#' @param full logical, is a more complete output desired (relevant only for doseFind)? if \code{FALSE} (default), only a point estimate of the dose (x) for the provided target rate is returned
#' @param extrapolate logical: should extrapolation beyond the range of estimated y values be allowed? Default \code{FALSE}.
#' @param dec (relevant only for doseFind) logical, is the true function is assumed to be monotone decreasing? Default \code{FALSE}.
#' @param estfun the name of the dose-response estimation function (relevant only for doseFind). For \code{invCIR} this is hard-coded as \code{\link{cirPAVA}}, which is also the default for \code{doseFind}.
#' @param ...	Other arguments passed on, from \code{invCIR} to \code{doseFind} and from there to the constructor functions that pre-process the input.

#' @return A data frame with
#' \itemize{
#' \item {target  }  { The user-provided target values of y, at which x is estimated}
#' \item {point } {  The point estimates of x}
#' \item {lowerPPconf,upperPPconf  }  { the interval-boundary estimates for a 'PP'=\code{100*conf} confidence interval}
#' }

#' @seealso \code{\link{pava}},\code{\link{cirPAVA}}


quickInverse<-function(y,x=NULL,wt=rep(1,length(y)),target,cir = TRUE, intfun = wilsonCI, conf = 0.9, ...)
{

if(cir) estfun<-cirPAVA else estfun<-drPAVA
pestimate=doseFind(y=y,x=x,wt=wt,estfun=estfun,target=target,full=TRUE,...) 

### Generate forward CIs for those targets we've managed to find, and deconstructing them...
foundPts=pestimate$targest[!is.na(pestimate$targest)]
cestimate=isotInterval(pestimate$fwd,conf=conf,intfun=intfun,outx=foundPts)
intBelow=target[!is.na(pestimate$targest)]-cestimate[,1]
intAbove=cestimate[,2]-target[!is.na(pestimate$targest)]

## Finding the slopes...
slopes=diff(pestimate$fwd$y)/diff(pestimate$fwd$x)
# Which segment do each of our target pt. estimates fall in?
segs=findInterval(foundPts,pestimate$fwd$x)
ciLow=foundPts-intAbove/slopes[segs]
ciHigh=foundPts+intBelow/slopes[segs]

dout=data.frame(target=target,point=pestimate$targest,low=NA,high=NA)
dout$low[!is.na(pestimate$targest)]=ciLow
dout$high[!is.na(pestimate$targest)]=ciHigh

names(dout)[3:4]=paste(c("lower","upper"),round(100*conf),"conf",sep="")
return(dout)
}






