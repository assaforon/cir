##' Inverse (dose-finding) estimate of a target x value (e.g., a percentile)
#'
#'
#' Inverse ("dose-finding") point estimation of a dose (x) for a specified target y value (e.g., a response rate), using the centered-isotonic-regression (\code{invCIR}) or a generic forward-estimation algorithm (\code{doseFind}).
#'
#'
#' The function works by calling \code{estfun} for forward estimation of the x-y relationship, then using \code{\link{approx}} with the x and y roles reversed for inverse estimation. The \code{extrapolate} option sets the \code{rule} argumet for this second call: 
#' \itemize{
#' \item {}{\code{extrapolate=TRUE} translates to \code{rule=2}, which actually means that the x value on the edge of the estimated y range will be assigned.}
#' \item{}{\code{extrapolate=FALSE} (default) translates to \code{rule=1}, which means an \code{NA} will be returned for any target y value lying outside the estimated y range.}
#' }
#' Note also that the function is set up to work with a vector of targets.
 
##' @author Assaf P. Oron \code{<assaf.oron.at.seattlechildrens.org>}

#' @param y  can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a \code{\link{DRtrace}} object or a \code{\link{doseResponse}} object. 
#' @param x dose levels (if not included in y). 
#' @param wt weights (if not included in y).
#' @param target A vector of target response rate(s), for which the percentile dose estimate is needed.
#' @param full logical, is a more complete output desired (relevant only for doseFind)? if \code{FALSE} (default), only a point estimate of the dose (x) for the provided target rate is returned
#' @param extrapolate logical: should extrapolation beyond the range of estimated y values be allowed? Default \code{FALSE}.
#' @param dec (relevant only for doseFind) logical, is the true function is assumed to be monotone decreasing? Default \code{FALSE}.
#' @param estfun the name of the dose-response estimation function (relevant only for doseFind). For \code{invCIR} this is hard-coded as \code{\link{cirPAVA}}, which is also the default for \code{doseFind}.
#' @param ...	Other arguments passed on, from \code{invCIR} to \code{doseFind} and from there to the constructor functions that pre-process the input.

#' @return under default, returns point estimate(s) of the dose (x) for the provided target rate(s). With \code{full=TRUE}, returns a list with
#' \itemize{
#' \item {xout } {  The said point estimate of x}
#' \item {input  }  {  a \code{doseResponse} object summarizing the input data}
#' \item {cir  }  {  a \code{doseResponse} object which is the \code{alg} output of the forward-estimation function}
#' }

#' @seealso \code{\link{pava}},\code{\link{cirPAVA}}

#' @export

doseFind<-function(y,x=NULL,wt=NULL,estfun=cirPAVA,target=NULL,full=FALSE,dec=FALSE,extrapolate=FALSE,...) {


### converting to doseResponse object 
### Basically it's a numeric data frame with x,y,weight, and x increasing
if(is.null(target)) stop("Must provide target to dose-find for.\n")
dr=doseResponse(y=y,x=x,wt=wt,...)
if (any(is.na(dr))) stop ("Missing values are not allowed.\n")  

# We start via forward estimation

pavout<-estfun(y=dr,full=TRUE,dec=dec)

newx<-pavout$alg$x
newy<-pavout$alg$y
newn=pavout$alg.wt

### The estimate is generated by using 'approx' with x and y interchanged

tout=approx(x=newy,y=newx,xout=target,ties="ordered",rule=1)$y
# targets outside y range are provisionally NA'ed... now if so desired, extrapolate
if(any(is.na(tout)) && extrapolate)
{
	lowTargets=which(target<min(newy))
	if(length(lowTargets)>0) tout[lowTargets]=extrapol(c(newy[1],newx[1]),c(newy[2],newx[2]),xout=target[lowTargets])
	hiTargets=which(target>max(newy))
	m=length(newx)
	if(length(hiTargets)>0) tout[hiTargets]=extrapol(c(newy[m-1],newx[m-1]),c(newy[m],newx[m]),xout=target[hiTargets])
	tout[!is.finite(tout)]=NA
}
	
#### output

if (!full)  return(tout) 

return (list(targest=tout,input=dr,fwd=pavout$alg,fwdDesign=pavout$output))
}

#' Point and Interval Inverse Estimation using CIR and IR
#'
#'
#' Convenience wrapper for point and interval estimation of the "dose" that would generate a \code{target} "response" value, using CIR and IR.

#' @param y  can be either of the following: y values (response rates), a 2-column matrix with positive/negative response counts by dose, a \code{\link{DRtrace}} object or a \code{\link{doseResponse}} object. 
#' @param x dose levels (if not included in y). 
#' @param wt weights (if not included in y).
#' @param target A vector of target response rate(s), for which the percentile dose estimate is needed.
#' @param full logical, is a more complete output desired (relevant only for doseFind)? if \code{FALSE} (default), only a point estimate of the dose (x) for the provided target rate is returned
#' @param extrapolate logical: should extrapolation beyond the range of estimated y values be allowed? Default \code{FALSE}. Note this affects only the point estimate; interval boundarie are extrapolated in any case.
#' @param dec (relevant only for doseFind) logical, is the true function is assumed to be monotone decreasing? Default \code{FALSE}.
#' @param estfun the name of the dose-response estimation function (relevant only for doseFind). For \code{invCIR} this is hard-coded as \code{\link{cirPAVA}}, which is also the default for \code{doseFind}.
#' @param extrapolate logical: should extrapolation beyond the range of estimated y values be allowed? Default \code{FALSE}.
#' @param ...	Other arguments passed on, from \code{invCIR} to \code{doseFind} and from there to the constructor functions that pre-process the input.

#' @return A data frame with
#' \itemize{
#' \item {target  }  { The user-provided target values of y, at which x is estimated}
#' \item {point } {  The point estimates of x}
#' \item {lowerPPconf,upperPPconf  }  { the interval-boundary estimates for a 'PP'=\code{100*conf} confidence interval}
#' }

#' @seealso \code{\link{pava}},\code{\link{cirPAVA}}


quickInverse<-function(y,x=NULL,wt=NULL,target,cir = TRUE, intfun = wilsonCI, conf = 0.9,xbounds=NULL,extrapolate=FALSE,seqDesign=FALSE,...)
{

if(cir) estfun<-cirPAVA else estfun<-oldPAVA
pestimate=doseFind(y=y,x=x,wt=wt,estfun=estfun,target=target,full=TRUE,extrapolate=extrapolate,...) 
foundPts=pestimate$targest[!is.na(pestimate$targest)]

### Establishing "logical" boundaries for CIs, at one spacing level out
if(is.null(xbounds)) xbounds=rep(NA,2)
m=length(pestimate$fwdDesign$x)
xmin=pestimate$fwdDesign$x[1]-(pestimate$fwdDesign$x[2]-pestimate$fwdDesign$x[1])
xmax=pestimate$fwdDesign$x[m]+(pestimate$fwdDesign$x[m]-pestimate$fwdDesign$x[m-1])
xbounds[1]=min(xmin,xbounds[1],na.rm=TRUE)
xbounds[2]=max(xmax,xbounds[2],na.rm=TRUE)

### CI using "global" interpolation

## Start with CIs at design points
	fcestimate=isotInterval(pestimate$fwdDesign,conf=conf,intfun=intfun,sequential=seqDesign)
	ciLow=doseFind(y=fcestimate$ciHigh,x=pestimate$fwdDesign$x,wt=pestimate$fwdDesign$weight,estfun=estfun,target=target[!is.na(pestimate$targest)],extrapolate=TRUE,...)
	#	ciLow[is.na(ciLow)]=min(x)
	ciLow[!is.finite(ciLow)]=xbounds[1]

	ciHigh=doseFind(y=fcestimate$ciLow,x=pestimate$fwdDesign$x,wt=pestimate$fwdDesign$weight,estfun=estfun,target=target[!is.na(pestimate$targest)],extrapolate=TRUE,...) 
#	ciHigh[is.na(ciHigh)]=max(x)
	ciHigh[!is.finite(ciHigh)]=xbounds[2]

dout=data.frame(target=target,point=pestimate$targest,low=NA,high=NA)
dout$low[!is.na(pestimate$targest)]=ciLow
dout$high[!is.na(pestimate$targest)]=ciHigh

names(dout)[3:4]=paste(c("lower","upper"),round(100*conf),"conf",sep="")
return(dout)
}






